#!/usr/bin/env python3
"""
Unified Database Models - Consolidates local and production models
Provides a single interface that automatically adapts to the environment
"""

import os
import json
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List, Union
from enum import Enum

# Environment detection
class Environment(Enum):
    LOCAL = "local"
    PRODUCTION = "production"

def detect_environment() -> Environment:
    """Detect the current environment"""
    # Check for environment variables or configuration
    if os.getenv('MCP_ENVIRONMENT') == 'production':
        return Environment.PRODUCTION
    
    # Check if we're in a containerized environment
    if os.path.exists('/.dockerenv') or os.getenv('DOCKER_CONTAINER'):
        return Environment.PRODUCTION
    
    # Default to local development
    return Environment.LOCAL

# Current environment
_CURRENT_ENV = detect_environment()

# ============================================================================
# UNIFIED MODELS
# ============================================================================

class UnifiedModel:
    """Base class for unified models that work in both environments"""
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format"""
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        """Create from dictionary"""
        return cls(**data)

class UnifiedInteraction(UnifiedModel):
    """Unified interaction model that works in both environments"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Set all attributes explicitly to ensure they're accessible
        self.interaction_id = kwargs.get('interaction_id', kwargs.get('id', None))
        self.timestamp = kwargs.get('timestamp', datetime.now())
        self.session_id = kwargs.get('session_id', None)
        self.user_id = kwargs.get('user_id', 'anonymous')
        self.interaction_type = kwargs.get('interaction_type', 'conversation_turn')
        self.prompt = kwargs.get('prompt', '')
        self.response = kwargs.get('response', '')
        self.full_content = kwargs.get('full_content', '')
        self.context_summary = kwargs.get('context_summary', '')
        self.semantic_keywords = kwargs.get('semantic_keywords', [])
        self.topic_category = kwargs.get('topic_category', 'general')
        self.status = kwargs.get('status', 'completed')
        self.execution_time_ms = kwargs.get('execution_time_ms', 0)
        self.meta_data = kwargs.get('meta_data', {})
        
        # Store additional attributes that might be passed
        for key, value in kwargs.items():
            if not hasattr(self, key):
                setattr(self, key, value)

class UnifiedSession(UnifiedModel):
    """Unified session model that works in both environments"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.session_id = kwargs.get('session_id', kwargs.get('id', None))
        self.user_id = kwargs.get('user_id', 'anonymous')
        self.started_at = kwargs.get('started_at', datetime.now())
        self.last_activity = kwargs.get('last_activity', datetime.now())
        self.total_interactions = kwargs.get('total_interactions', 0)
        self.current_context_id = kwargs.get('current_context_id', None)
        self.context_history = kwargs.get('context_history', [])
        self.session_summary = kwargs.get('session_summary', '')
        self.meta_data = kwargs.get('meta_data', {})

class UnifiedConversationContext(UnifiedModel):
    """Unified conversation context model that works in both environments"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.session_id = kwargs.get('session_id', None)
        self.user_id = kwargs.get('user_id', 'anonymous')
        self.context_summary = kwargs.get('context_summary', '')
        self.semantic_context = kwargs.get('semantic_context', {})
        self.key_topics = kwargs.get('key_topics', [])
        self.user_preferences = kwargs.get('user_preferences', {})
        self.project_context = kwargs.get('project_context', {})
        self.context_type = kwargs.get('context_type', 'general')
        self.relevance_score = kwargs.get('relevance_score', 0.0)
        self.usage_count = kwargs.get('usage_count', 0)
        self.created_at = kwargs.get('created_at', datetime.now())
        self.updated_at = kwargs.get('updated_at', datetime.now())

class UnifiedConversation(UnifiedModel):
    """Unified conversation model that works in both environments"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.session_id = kwargs.get('session_id', None)
        self.user_id = kwargs.get('user_id', 'anonymous')
        self.conversation_type = kwargs.get('conversation_type', 'general')
        self.title = kwargs.get('title', '')
        self.summary = kwargs.get('summary', '')
        self.interaction_count = kwargs.get('interaction_count', 0)
        self.created_at = kwargs.get('created_at', datetime.now())
        self.updated_at = kwargs.get('updated_at', datetime.now())
        self.meta_data = kwargs.get('meta_data', {})

# ============================================================================
# STORAGE AND SESSION FACTORY
# ============================================================================

class UnifiedStorage(UnifiedModel):
    """Unified storage interface that works in both environments"""
    
    def __init__(self):
        super().__init__()
        self._env = _CURRENT_ENV
        self._local_interactions: List[UnifiedInteraction] = []
        self._local_sessions: List[UnifiedSession] = []
        self._local_conversations: List[UnifiedConversation] = []
        
        # Initialize with sample data for local development
        if self.is_local and not self._local_sessions:
            self._initialize_sample_data()
    
    @property
    def is_local(self) -> bool:
        return self._env == Environment.LOCAL
    
    @property
    def is_production(self) -> bool:
        return self._env == Environment.PRODUCTION
    
    def _initialize_sample_data(self):
        """Initialize with sample data for local development"""
        # Create sample session
        sample_session = UnifiedSession(
            session_id="sample-session",
            user_id="sample-user",
            started_at=datetime.now(),
            total_interactions=0
        )
        self._local_sessions.append(sample_session)
    
    def add_interaction(self, interaction: UnifiedInteraction):
        """Add an interaction"""
        if self.is_local:
            self._local_interactions.append(interaction)
        # In production, this would save to database
    
    def get_interactions(self, limit: int = 10) -> List[UnifiedInteraction]:
        """Get interactions"""
        if self.is_local:
            return self._local_interactions[-limit:] if limit else self._local_interactions
        # In production, this would query database
        return []
    
    def add_session(self, session: UnifiedSession):
        """Add a session"""
        if self.is_local:
            self._local_sessions.append(session)
        # In production, this would save to database
    
    def get_sessions(self) -> List[UnifiedSession]:
        """Get sessions"""
        if self.is_local:
            return self._local_sessions
        # In production, this would query database
        return []
    
    def add_conversation(self, conversation: UnifiedConversation):
        """Add a conversation"""
        if self.is_local:
            self._local_conversations.append(conversation)
        # In production, this would save to database
    
    def get_conversations(self) -> List[UnifiedConversation]:
        """Get conversations"""
        if self.is_local:
            return self._local_conversations
        # In production, this would query database
        return []

class UnifiedSessionFactory:
    """Unified session factory that works in both environments"""
    
    def __init__(self):
        self._env = _CURRENT_ENV
    
    def __call__(self):
        """Create a new session"""
        if self.is_production:
            try:
                # Try to use SQLAlchemy session
                from sqlalchemy.orm import Session
                # Use local implementation instead of circular import
                SessionLocal = UnifiedSessionFactory()
                return SessionLocal()
            except Exception:
                # Fallback to mock session
                return MockSession()
        else:
            return MockSession()
    
    @property
    def is_local(self) -> bool:
        return self._env == Environment.LOCAL
    
    @property
    def is_production(self) -> bool:
        return self._env == Environment.PRODUCTION

class MockSession:
    """Mock database session for local development"""
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
    
    def query(self, model_class):
        return MockQuery(model_class)
    
    def add(self, obj):
        pass
    
    def commit(self):
        pass
    
    def close(self):
        pass

class MockQuery:
    """Mock query for local development"""
    
    def __init__(self, model_class):
        self.model_class = model_class
        self._filters = []
        self._limit = None
    
    def filter(self, *args):
        self._filters.extend(args)
        return self
    
    def limit(self, limit):
        self._limit = limit
        return self
    
    def order_by(self, *args):
        return self
    
    def all(self):
        return []
    
    def first(self):
        return None
    
    def count(self):
        return 0

# ============================================================================
# MOCK COLUMN CLASS FOR BACKWARD COMPATIBILITY
# ============================================================================

class MockColumn:
    """Mock SQLAlchemy column for backward compatibility"""
    
    def __init__(self, name):
        self.name = name
    
    def desc(self):
        return f"{self.name} DESC"
    
    def __ge__(self, other):
        return True  # Always return True for comparison operations
    
    def __le__(self, other):
        return True
    
    def __gt__(self, other):
        return True
    
    def __lt__(self, other):
        return True
    
    def __eq__(self, other):
        return True
    
    def __ne__(self, other):
        return True

# ============================================================================
# COMPATIBILITY ALIASES
# ============================================================================

# For backward compatibility, provide the same names as the original files
# These are now class aliases that maintain the exact same interface

class AgentInteraction(UnifiedInteraction):
    """Backward compatibility wrapper for AgentInteraction"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

class Session(UnifiedSession):
    """Backward compatibility wrapper for Session"""
    
    # SQLAlchemy-style class attributes for backward compatibility
    id = MockColumn("id")
    user_id = MockColumn("user_id")
    started_at = MockColumn("started_at")
    last_activity = MockColumn("last_activity")
    total_interactions = MockColumn("total_interactions")
    current_context_id = MockColumn("current_context_id")
    context_history = MockColumn("context_history")
    session_summary = MockColumn("session_summary")
    meta_data = MockColumn("meta_data")

class ConversationContext(UnifiedConversationContext):
    """Backward compatibility wrapper for ConversationContext"""
    
    # SQLAlchemy-style class attributes for backward compatibility
    id = MockColumn("id")
    session_id = MockColumn("session_id")
    user_id = MockColumn("user_id")
    context_summary = MockColumn("context_summary")
    semantic_context = MockColumn("semantic_context")
    key_topics = MockColumn("key_topics")
    user_preferences = MockColumn("user_preferences")
    project_context = MockColumn("project_context")
    context_type = MockColumn("context_type")
    relevance_score = MockColumn("relevance_score")
    usage_count = MockColumn("usage_count")
    created_at = MockColumn("created_at")
    updated_at = MockColumn("updated_at")

# ============================================================================
# BACKWARD COMPATIBILITY ALIASES
# ============================================================================

# For backward compatibility, provide the same names as the original files
AgentInteraction = UnifiedInteraction
Session = UnifiedSession
ConversationContext = UnifiedConversationContext
LocalInteraction = UnifiedInteraction
LocalSession = UnifiedSession
LocalConversation = UnifiedConversation

# Storage functions for backward compatibility
_unified_storage = UnifiedStorage()

def add_local_interaction(interaction: UnifiedInteraction):
    """Add a local interaction (backward compatibility)"""
    _unified_storage.add_interaction(interaction)

def get_local_interactions(limit: int = 10) -> List[UnifiedInteraction]:
    """Get local interactions (backward compatibility)"""
    return _unified_storage.get_interactions(limit)

def add_local_session(session: UnifiedSession):
    """Add a local session (backward compatibility)"""
    _unified_storage.add_session(session)

def get_local_sessions() -> List[UnifiedSession]:
    """Get local sessions (backward compatibility)"""
    return _unified_storage.get_sessions()

def add_local_conversation(conversation: UnifiedConversation):
    """Add a local conversation (backward compatibility)"""
    _unified_storage.add_conversation(conversation)

def get_local_conversations() -> List[UnifiedConversation]:
    """Get local conversations (backward compatibility)"""
    return _unified_storage.get_conversations()

# Database functions for backward compatibility
def get_session_factory():
    """Get database session factory (backward compatibility)"""
    return UnifiedSessionFactory()

def get_database_url():
    """Get database URL (backward compatibility)"""
    if _CURRENT_ENV == Environment.PRODUCTION:
        try:
            from config import Config
            return Config.get_database_url()
        except ImportError:
            pass
    
    # Default to local SQLite
    return "sqlite:///./data/agent_tracker.db"

def init_database():
    """Initialize database (backward compatibility)"""
    if _CURRENT_ENV == Environment.PRODUCTION:
        try:
            # Use local implementation instead of circular import
            return None
        except ImportError:
            pass
    
    # For local development, just ensure the data directory exists
    os.makedirs("./data", exist_ok=True)
    return None

# ============================================================================
# ENVIRONMENT INFORMATION
# ============================================================================

def get_environment_info() -> Dict[str, Any]:
    """Get information about the current environment"""
    return {
        'environment': _CURRENT_ENV.value,
        'is_local': _CURRENT_ENV == Environment.LOCAL,
        'is_production': _CURRENT_ENV == Environment.PRODUCTION,
        'database_url': get_database_url(),
        'models_available': {
            'UnifiedInteraction': True,
            'UnifiedSession': True,
            'UnifiedConversationContext': True,
            'UnifiedConversation': True,
            'UnifiedStorage': True,
            'UnifiedSessionFactory': True
        }
    }

def switch_environment(env: Environment):
    """Switch to a different environment (for testing)"""
    global _CURRENT_ENV
    _CURRENT_ENV = env
    print(f"ðŸ”„ Switched to {env.value} environment")

# ============================================================================
# INITIALIZATION
# ============================================================================

if __name__ == "__main__":
    # Print environment information
    info = get_environment_info()
    print("ðŸš€ Unified Models System")
    print("=" * 40)
    print(f"Environment: {info['environment']}")
    print(f"Database: {info['database_url']}")
    print(f"Models: {', '.join(info['models_available'].keys())}")
    print("=" * 40)
